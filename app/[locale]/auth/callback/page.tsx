'use client'

import { useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { useSupabase } from '@/components/providers/SupabaseProvider'
import { LoadingPage } from '@/components/ui/Loading'

export default function AuthCallbackPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const { supabase } = useSupabase()

  useEffect(() => {
    const handleCallback = async () => {
      try {
        const code = searchParams.get('code')
        const error = searchParams.get('error')
        const errorCode = searchParams.get('error_code')
        const errorDescription = searchParams.get('error_description')
        const type = searchParams.get('type')

        console.log('üîç Callback params:', { code, error, errorCode, errorDescription, type })

        // Se houver erro no OAuth
        if (error) {
          console.error('‚ùå OAuth Error:', { error, errorCode, errorDescription })
          
          // Log adicional para debug quando o erro est√° vazio
          if (!error && !errorCode && !errorDescription) {
            console.error('üîç OAuth Error vazio detectado - verificando par√¢metros da URL:', {
              searchParams: Object.fromEntries(searchParams.entries()),
              url: window.location.href,
              timestamp: new Date().toISOString()
            })
            
            // Verificar se h√° outros par√¢metros que podem indicar erro
            const allParams = Object.fromEntries(searchParams.entries())
            console.log('üîç Todos os par√¢metros da URL:', allParams)
            
            // Se n√£o h√° c√≥digo nem erro espec√≠fico, pode ser um problema de configura√ß√£o
            if (!code) {
              console.error('‚ö†Ô∏è Nenhum c√≥digo OAuth encontrado - poss√≠vel problema de configura√ß√£o')
              router.push('/auth?error=oauth_configuration&message=Problema na configura√ß√£o do OAuth. Tente novamente.')
              return
            }
          }
          
          // Tratamento espec√≠fico para erro de viola√ß√£o de chave prim√°ria
          if (error === 'server_error' && errorDescription?.includes('profiles_pkey')) {
            console.log('üîß Erro de duplica√ß√£o de perfil detectado - tentando recuperar sess√£o...')
            
            try {
              // Tentar obter a sess√£o atual
              const { data: sessionData, error: sessionError } = await supabase.auth.getSession()
              
              if (sessionData.session) {
                console.log('‚úÖ Sess√£o recuperada ap√≥s erro de duplica√ß√£o')
                
                // Verificar se √© admin e redirecionar adequadamente
                try {
                  const { data: userData, error: userError } = await supabase
                    .from('users')
                    .select('role')
                    .eq('id', sessionData.session.user.id)
                    .single()
                  
                  if (!userError && userData?.role === 'admin') {
                    console.log('üîê Usu√°rio admin detectado, redirecionando para /admin')
                    window.location.href = '/admin'
                    return
                  } else {
                    console.log('üè† Redirecionando para p√°gina principal...')
                    router.push('/')
                    return
                  }
                } catch (userCheckError) {
                  console.error('Erro ao verificar role do usu√°rio:', userCheckError)
                  router.push('/')
                  return
                }
              } else {
                console.log('‚ùå N√£o foi poss√≠vel recuperar a sess√£o')
                router.push('/auth?error=profile_duplication&message=Erro ao processar login. Tente novamente.')
                return
              }
            } catch (recoveryError) {
              console.error('Erro ao tentar recuperar sess√£o:', recoveryError)
              router.push('/auth?error=profile_duplication&message=Erro ao processar login. Tente novamente.')
              return
            }
          }
          
          // Tratamento espec√≠fico para erros de OTP expirado
          if (error === 'access_denied' && (errorCode === 'otp_expired' || errorDescription?.includes('expired'))) {
            console.log('üîó Link expirado detectado, redirecionando para nova solicita√ß√£o')
            router.push('/auth?error=link_expired&message=O link de redefini√ß√£o expirou. Solicite um novo link abaixo.')
            return
          }
          
          // Outros erros de acesso negado
          if (error === 'access_denied') {
            router.push('/auth?error=access_denied&message=Acesso negado. Tente fazer uma nova solicita√ß√£o.')
            return
          }
          
          router.push(`/auth?error=${encodeURIComponent(errorDescription || error)}`)
          return
        }

        if (code) {
          console.log('üîë Processando c√≥digo de autentica√ß√£o...')
          
          // Primeira tentativa
          let { error: authError, data } = await supabase.auth.exchangeCodeForSession(code)
          
          // Se for erro de PKCE, tentar m√∫ltiplas abordagens
          if (authError && authError.message?.includes('code_verifier')) {
            console.log('üîß Erro PKCE detectado, tentando m√∫ltiplas solu√ß√µes...')
            
            let retrySuccess = false
            
            // Tentativa 1: Limpar storage e tentar novamente
            try {
              console.log('üîÑ Tentativa 1: Limpar storage...')
              
              // Limpar storage relacionado ao auth
              const keysToRemove = [
                'armazem-sao-joaquim-auth',
                'supabase.auth.token',
                'supabase.auth.refreshToken',
                'supabase.auth.expiresAt',
                'supabase.auth.expiresIn',
                'supabase.auth.tokenType',
                'supabase.auth.provider',
                'supabase.auth.providerToken',
                'supabase.auth.providerRefreshToken',
                'supabase.auth.providerExpiresAt',
                'supabase.auth.providerExpiresIn',
                'supabase.auth.providerTokenType',
                'supabase.auth.providerScope',
                'supabase.auth.providerId',
                'supabase.auth.providerEmail',
                'supabase.auth.providerName',
                'supabase.auth.providerAvatar',
                'supabase.auth.providerPicture',
                'supabase.auth.providerLocale',
                'supabase.auth.providerTimezone',
                'supabase.auth.providerEmailVerified',
                'supabase.auth.providerPhoneNumber',
                'supabase.auth.providerPhoneNumberVerified',
                'supabase.auth.providerSub',
                'supabase.auth.providerIat',
                'supabase.auth.providerExp',
                'supabase.auth.providerJti',
                'supabase.auth.providerIss',
                'supabase.auth.providerAud',
                'supabase.auth.providerAzp',
                'supabase.auth.providerNonce',
                'supabase.auth.providerAcr',
                'supabase.auth.providerAmr',
                'supabase.auth.providerAtHash',
                'supabase.auth.providerCHash'
              ]
              
              keysToRemove.forEach(key => {
                try {
                  localStorage.removeItem(key)
                } catch (e) {
                  // Ignore errors
                }
              })
              
              console.log('‚úÖ Storage limpo, tentando novamente...')
              
              // Segunda tentativa ap√≥s limpeza
              const retryResult = await supabase.auth.exchangeCodeForSession(code)
              if (retryResult.error) {
                console.error('‚ùå Segunda tentativa falhou:', retryResult.error.message)
              } else {
                data = retryResult.data
                authError = null
                retrySuccess = true
                console.log('‚úÖ Segunda tentativa bem-sucedida!')
              }
            } catch (cleanupError) {
              console.error('‚ùå Erro ao limpar storage:', cleanupError)
            }
            
            // Tentativa 2: Se ainda falhou, tentar com configura√ß√£o alternativa
            if (!retrySuccess) {
              try {
                console.log('üîÑ Tentativa 2: Configura√ß√£o alternativa...')
                
                // Tentar com configura√ß√£o diferente
                const tempResult = await supabase.auth.exchangeCodeForSession(code)
                if (tempResult.error) {
                  console.error('‚ùå Tentativa alternativa falhou:', tempResult.error.message)
                } else {
                  data = tempResult.data
                  authError = null
                  retrySuccess = true
                  console.log('‚úÖ Tentativa alternativa bem-sucedida!')
                }
              } catch (altError) {
                console.error('‚ùå Erro na tentativa alternativa:', altError)
              }
            }
            
            // Se todas as tentativas falharam, manter o erro original
            if (!retrySuccess) {
              console.error('‚ùå Todas as tentativas falharam, mantendo erro original')
            }
          }
          
          if (authError) {
            console.error('‚ùå Auth Exchange Error:', authError)
            
            // Tratamento espec√≠fico para tokens expirados
            if (authError.message?.includes('expired') || authError.message?.includes('invalid')) {
              router.push('/auth?error=link_expired&message=O link de redefini√ß√£o expirou. Solicite um novo link.')
              return
            }
            
            // Tratamento espec√≠fico para erro PKCE
            if (authError.message?.includes('code_verifier')) {
              console.error('üîß Erro PKCE persistente - redirecionando para nova tentativa')
              router.push('/auth?error=pkce_error&message=Erro de autentica√ß√£o. Tente fazer login novamente.')
              return
            }
            
            const errorMessage = typeof authError === 'object' && authError && 'message' in authError 
              ? (authError as any).message 
              : 'Authentication failed'
            router.push(`/auth?error=${encodeURIComponent(errorMessage)}`)
            return
          }

          console.log('‚úÖ Autentica√ß√£o bem-sucedida:', { type, session: !!data.session })

          // O trigger handle_new_user() j√° cria o profile automaticamente
          // N√£o precisamos chamar upsertProfile() aqui para evitar race conditions
          if (data.user) {
            console.log('üë§ Profile ser√° criado automaticamente pelo trigger')
          }

          // Verificar se √© recovery (redefini√ß√£o de senha)
          if (type === 'recovery') {
            console.log('üîê Redirecionando para reset de senha...')
            router.push('/auth/reset-password')
            return
          }

          // Aguardar um pouco para garantir que a sess√£o seja propagada para o servidor
          console.log('‚è≥ Aguardando propaga√ß√£o da sess√£o ap√≥s OAuth...')
          await new Promise(resolve => setTimeout(resolve, 1500))
          
          // Sucesso - verificar se √© admin e redirecionar adequadamente
          try {
            // Verificar se √© admin por email primeiro (mais confi√°vel)
            if (data.user.email === 'armazemsaojoaquimoficial@gmail.com') {
              console.log('üîê Usu√°rio admin detectado por email, redirecionando para /admin')
              window.location.href = '/admin'
              return
            }
            
            // Fallback: verificar na tabela profiles
            const { data: userData, error: userError } = await supabase
              .from('profiles')
              .select('role')
              .eq('id', data.user.id)
              .single()
            
            if (!userError && userData?.role === 'admin') {
              console.log('üîê Usu√°rio admin detectado por role, redirecionando para /admin')
              window.location.href = '/admin'
              return
            } else {
              console.log('üè† Redirecionando para p√°gina principal...')
              router.push('/')
            }
          } catch (error) {
            console.error('Erro ao verificar role do usu√°rio:', error)
            // Fallback para p√°gina inicial em caso de erro
            console.log('üè† Redirecionando para p√°gina principal (fallback)...')
            router.push('/')
          }
          return
        }

        // Se n√£o h√° c√≥digo nem erro, redireciona para auth
        console.log('‚ö†Ô∏è Nenhum c√≥digo ou erro encontrado, redirecionando para auth')
        router.push('/auth')
      } catch (error) {
        console.error('üí• Unexpected error during auth callback:', error)
        router.push('/auth?error=auth_callback_error&message=Erro inesperado durante autentica√ß√£o')
      }
    }

    handleCallback()
  }, [searchParams, supabase, router])

  return (
    <LoadingPage 
      title="Processando autentica√ß√£o..." 
      subtitle="Aguarde enquanto finalizamos seu login"
    />
  )
} 